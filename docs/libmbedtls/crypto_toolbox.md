# 密码学工具箱

密码学领域一般将上节提到的六个要素称为密码学工具箱。本节将对上一节提到的，密码学中六种主要的密码技术分别顺序进行描述，并同时配以此种技术中的一个或多个样例代码。

## 单向散列函数 SHA256

单向散列函数根据消息的内容计算出消息的散列值，散列值作为消息的摘要，可以用来检查消息的完整性(Integrity)。同一个单向散列函数算法输出的散列值是固定的，不随消息长度的不同而变化。常见的单向散列算法有 MD4/5 系列与 SHA 系列。MD4/5 系列算法由于安全性问题而不应该使用，应该主要使用 SHA 系列算法，其中 SHA-1 由于安全问题不应使用，应该选用 SHA-2 与 SHA-3 系列。MD5 与 SHA 算法家族均基于 MD4 的基本原理设计实现，mbedtls 的单向散列通用接口均赋以 md 前缀可能就源于此。由单向散列函数的名称可知，`单向`意味着从消息的散列值反推消息本身，在安全的单向散列函数中几乎是不可能的事情。单向散列函数和其他密码技术息息相关，许多其他密码技术都用到了单向散列函数。

在消息传递过程中，常将消息本身与计算出的消息散列值一同发送给对方，对方在接收到消息后计算其散列值，并与接收到的散列值比较，如果二者相同，则说明消息没有经过篡改或者产生传输错误。

如下算法计算消息"abc"的散列值，采用 SHA256 算法。其计算流程为经典的 start->update->finish 模式。填入消息在 update 步骤进行，update 函数可以被调用多次以多次填入消息。代码中使用的是 md 单向散列通用接口函数，也可使用各个单项散列函数独立的子模块接口，如`mbedtls_sha256_starts`。

[sha256](../src/libmbedtls/toolbox/sha256.c ':include')

除此之外，需要注意最新推出的 SHA-3 系列算法与以往的 MD 系列的单向散列算法内部结构完全不同，采用海绵结构可以让 SHA-3 算法免疫针对 SHA-1 系列的攻击。

## 对称加密算法 AES_128_CBC / AES_128_CTR

高级加密标准 AES 算法是当前流行的对称加密算法，用以保证消息的机密性(Confidentiality)。对称加密算法的双方使用相同的密进行加密或解密，发送方使用共享密钥加密消息并传输密文，接收方使用共享密钥解密接收到的密文。

实际上，AES_128_CBC 或者 AES_128_CTR 等名称是一个组合。其中 AES 是新一代的对称加密算法，它单次只能处理一个固定长度的分组数据，其单次只能加密或解密 128 位数据。然而实际场景中被操作的消息通常都不是仅仅有 128 位，这就要引入`分组模式`，也即 CBC/CTR 等分组模式，在需要加密的明文长度超出分组长度时，对明文进行分组处理，然后分别对各组进行加解密。最后，其中的 128 指的是密钥长度，并不是分组长度，分组长度固定为 128 位，这点要尤其注意。

AES 以及上一代 DES/三重 DES 均属于分组密码(block cipher)。与此对应的另一类对称加密算法为流密码(stream cipher)，常见的流密码有 chacha20/rc4 等，一次性密码本也属于流密码。

对于分组密码，一般均以分组(block)为单位进行加密，比如以 64bit 或者 128bit 为单位。而流密码是对数据流进行连续的处理，一般以 1bit,8bit 或者 32bit 为单位进行。可以看到，从大小来看，分组密码处理单位较大，较为粗糙，而流密码的处理单位较小。但是在中间地带的大小，界定可能会较为模糊。除此之外，分组密码各组独立，故无需记录内部状态来记录加密进度。而流密码是对一串数据流连续处理，需要保持内部状态，这也是区分它们的一个界限。

前面提到，在分组密码算法中，需要对明文进行分组操作，也即需要引入`分组模式`。常见的分组模式有 ECB/CBC/CFB/OFB/CTR 等等，不同分组模式的计算过程不同，安全性和具体实现也不同。ECB/CBC 是经典的分组密码实现，然而 CFB/OFB/CTR 这三种模式却有所不同。在 CFB/OFB/CTR 模式中，存在由分组密码算法所生成的比特序列，即密钥流(key stream),明文数据被逐比特加密，因此这些模式也可看作是一种**使用分组密码来实现的流密码**方式。

除此之外，如在 CBC 等经典分组模式中，其分组的实现方式会造成最后一组数据填充不满最后一个分组大小的情况，这时就要用到`消息填充`这种技术，它会对不满的分组进行填充。而在 CTR 等使用分组密码来实现的流密码模式中，根据其实现方式，就不必进行消息的填充。

> 单独使用对称加密算法与消息验证码的简单结合已经被证实是不安全的。实际场景中需要使用 AEAD 模式<sup>[[1]](https://shadowsocks.org/en/wiki/Stream-Ciphers.html)</sup>，这种模式中，使用新的算法在内部同时实现加密和认证，而不是简单结合加密与认证。一种常见的 AEAD 模式为 AES_128_GCM，GCM(Galois/Counter Mode)模式是在 CTR 的分组模式基础上增加了认证功能,这种模式能在 CTR 模式生成密文的**同时**生成用于认证的消息，从而判断"密文是否通过合法的加密过程产生"。通过这种机制，即使攻击者发送伪造密文，也能够被识别。此小节仅为教学用途，不要在实际场景中使用。

如下代码使用 mbedtls 的 cipher 通用接口实现 AES_128_CBC 与 AES_128_CTR 的加密过程。注意，CBC 模式进行了填充，而 CTR 模式不需要填充。代码中一个重要参数为 IV，即初始化向量(Initialization Vector)。CBC 模式中，初始化向量作用于对第一个明文/密文分组的加密/解密。注意，初始化向量要保证在每次通讯时都不同，并且是不可预测的，这样即使每次通讯被加密的消息完全相同，得到的密文也不同，在这种情况下，窃听者也无法获得明文与密文的对应关系。在 CTR 模式中，IV 也常被称作`一次性整数 Nonce`，在 CTR 模式中，Nonce 配合 Counter 参与到每次加密解密的运算中。与 IV 相比，Nonce 可以不随机或伪随机，但一定不能重复。

[aes128cbc_ctr](../src/libmbedtls/toolbox/aes128cbc_ctr.c ':include')

## 消息认证码 HMAC / AES_128_GCM

消息验证码除了可以像单向散列函数一样验证数据完整性，还可以验证对方的真实性。与单向散列函数不同的是，除了输入消息意外，消息验证码通讯双方还需要一个共享密钥。

通过单向散列函数实现的消息认证码，此类方法统称为 HMAC，如 HMAC-SHA1,HMAC-SHA256 等，这种情况下可以看作是单项散列函数和密钥的组合。另外一类方式为使用分组加密模式构造消息认证码算法，如 CBC-MAC\CMAC 等，分组密码的密钥可以同时作为消息验证码中的共享密钥。最后，流密码与公钥非对称密码也可用来实现消息认证码。以上这些方法可以提供信息安全中的完整性与真实性(认证机制)的保障。

HMAC 算法需要两个参数，一个称为秘钥，此处为 secret，另一个称为消息，此处为 msg，消息认证码保留在 mac 数组中。可以看到输出中 HMAC 消息认证码长度和内部的单向散列算法 SHA256 的消息摘要长度是相等的，所以 HMAC 的计算结果一定为 32 字节。在 mbedtls 中，消息认证码的生成分为三个步骤：

- mbedtls_md_hmac_starts 设置密钥
- mbedtls_md_hmac_update 填充消息，本示例仅填充了一次
- mbedtls_md_hmac_finish 生成消息认证码，结果保存至 mac 中

注意，在 mbedtls_md_setup 函数中赋值 1，为使用 HMAC。

[hmac](../src/libmbedtls/toolbox/hmac.c ':include')

---

最后，更重要的是应用更广泛的 AE(Authenticated Encryption)/AEAD(Authenticated Encryption with Associated Data) 加密认证模式，如 AES_128_GCM 与 AES_128_CCM。不同于单独的消息认证码，这种算法兼顾真实性与完整性，还可同时提供机密性的保障。目前 shadowsocks 建议使用的 AEAD 模式中的 AES_128_GCM 、 AES_256_GCM 与 CHACHA20_POLY1305。认证加密算法可同时输出密文与消息认证码，如今已被广泛应用。

CCM 使用 CBC-MAC 算法以及 CTR 模式。在认证过程，对格式化后的数据进行 CBC-MAC 运算，得到消息认证码，然后对消息认证码进行 CTR 模式加密得到最终的消息验证码结果。同时进行明文的加密过程，最终将两个过程中生成的密文与消息验证码作为最终输出结果。

GCM 使用 GHASH 算法以及 GCTR 模式。GCM 首先使用 GCTR 对明文进行加密得到密文，随后将密文以及附加数据送入 GHASH 函数运算，最后再将运算结果用 GCTR 进行加密得到最终的消息认证码。在 CTR 加密与 MAC 值计算时，使用的是相同的密钥。

GCM 与 CCM 算法均基于 CTR 模式实现，由于 CTR 模式无需填充消息，且可以并行计算，使得基于 CTR 的认证加密方案成为当前最高效的模式。因为它们的高效性和安全性，在很多安全协议和应用协议中都应用广泛，如 TLS1.3 中仅保留了基于 GCM/CCM 的认证加密算法。

如下代码实现了一个 AES_128_GCM 的加密、解密、验证过程。需要注意的是，解密接口仅输出明文，认证结果通过返回值判断。CCM 的使用方式与 GCM 非常类似，只需将其中的模式改为 MBEDTLS_CIPHER_AES_128_CCM 即可。其中几个重要参数如下:

- 明文 PT
- 密钥 KEY
- 初始化向量 IV
- 相关数据 ADD
- 密文 CT
- 消息认证码 TAG

[aes128gcm](../src/libmbedtls/toolbox/aes128gcm.c ':include')

## 伪随机数生成器

伪随机数生成器可以使用对称密码、单向散列函数、或公钥密码来构建。

随机数之所以重要，是因为其在很多场景中都发挥重要作用：

- 在对称密码与消息认证码中用于生成密钥
- 在公钥密码与数字签名中生成密钥对
- 在分组密码的多种模式中生成初始化向量
- 在 CTR 模式以及防御重放攻击时生成 Nonce
- 在基于口令的密码模式中(PBE, Password Based Encryption)生成盐
- ...

随机数从宽松到严格分为如下三类，更严格的分类具备更宽松的分类的性质：

- 随机性：不存在统计学偏差，是完全杂乱的数列。仅具备随机性的随机数不能用于密码学领域。
- 不可预测性：不能从过去的数列推测出下一个出现的数。比如可用单向散列函数的单向性和密码的机密性保证此性质。具备不可预测性即可用于密码学领域。
- 不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。仅靠软件无法实现此性质，因为计算机本身仅具备有限的内部状态，在经过某个长度的周期后定会出现重复。要实现不可重现性，需要从不可重现的无力现象提取信息，如用户鼠标移动，温度声音变化，热噪声变化等。这种随机数称为真随机数。

注意，一些编程语言通常都会提供用于生成随机数列的方法或函数，使用时一定需要注意查询其是否具备不可预测性，来用于密码学领域。

通过硬件生成的，无法预测和重现的自然现象生成的是真随机数，这种硬件设备称为随机数生成器(RNG, Random Number Generator)。而生成随机数的软件称为伪随机数生成器(PRN, Pseudo Random Number Generator)，因为软件无法生成真的随机数，所以叫做"伪"。

伪随机数生成器的流程一般为用一个硬件强熵源，生成真随机数种子。随后伪随机数生成器根据内部状态和种子生成伪随机数序列，最后改变内部状态。需要注意，内部状态与种子需要保密。

CTR_DRBG (CTR Deterministic Random Bit Generator)是一种常用的伪随机数生成算法，它使用 AES-256 分组密码的 CTR 模式作为基础算法，可以将其理解为一个加密过程，加密的结果为期望的随机数序列。

使用 CTR_DRBG 生成随机数时，基础流程是首先使用一个强熵源，硬件真随机数发生器一般被定义为强熵源。在 linux 上，mbedtls 默认使用/dev/urandom 作为强熵源，注意，如今/dev/random 和 /dev/urandom 已经近乎相似。如果某个平台没有默认的强熵源，则需要使用 mbedtls_entropy_add_source 函数进行添加自定义强熵源。除了熵源，还需要一个自定义字符串对种子进行初始化，在 mbedtls_ctr_drbg_seed 生成种子后，最后使用 mbedtls_ctr_drbg_random 生成随机数。

[ctr_drbg_random](../src/libmbedtls/toolbox/ctr_drbg_random.c ':include')

---

在很多方面，如密钥生成、素数生成及检测均依赖随机数模块，如下代码是一个使用 CTR_DRBG 生成大素数的例子，这里为生成一个 256 字节的大素数，并进行素性检测。由于此处素数长度较大，因此可能需要较长时间生成。

可以看到，首先需要初始化两个大数结构体 P 和 Q,其中 P 为生成的素数结果，Q=(P-1)/2,用于素性检测。在这个例子中也可以看到大数操作的例子。在 mbedtls_mpi_gen_prime 中，flag 标志位设为 1 则保证(P-1)/2 也为素数。

[ctr_drbg_big_prime](../src/libmbedtls/toolbox/ctr_drbg_big_prime.c ':include')

## 公钥非对称密码算法 RSA

在前面讲过的对称密码体系中，一个无法避免的问题就是对称加密中密钥配送的问题。如果双方想要用对称加密进行通讯，就必须安全的发送对称密钥。对于对称密码的密钥配送问题，有如下一些解决方案，而公钥密码系统就是其中一个较好的方式。

- 事先通过某种确认安全的方式共享密钥，如面对面发送。
- 通过系统内建设的密钥分配中心(KDC, Key Distribution Center)发送共享密钥。
- 通过 DH 密钥交换来解决,在下一小节将详述。
- 通过公钥密码来解决。

RSA 算法是一种常见的公钥密码算法，可用于公钥加密以及数字签名(本节后续会讲到)。与对称加密中共享密钥的方式不同，RSA 加密解密过程中使用不同的密钥。在 RSA 用于公钥加密时，公钥用来加密，私钥用来解密。

RSA 算法的加密过程比对称加密算法慢很多，通常不适合对大量数据进行加解密。这是因为 RSA 加解密的过程存在大量的模幂运算，其中公钥操作的加密加速解决方式是指定一个固定的短公开指数进行快速计算，短公开指数通常被标记为 e,常用的值为 3\7\65537。私钥操作的解密加速解决方式为使用中国剩余定理(CRT),mbeltls 默认已启用 CRT。RSA 算法在实际应用中常用于加解密小数据片段，如密钥协商中密钥的配送：首先服务器传递公钥，客户端用公钥加密后续要用到的对称式加密的共享密钥，发送给服务器。服务器接收到后，用私钥解密，从而双方均得到对称式加密的共享密钥用于后续通信。这也是混合密码系统的一个应用场景。

> RSA 算法没有[向前安全性](https://en.wikipedia.org/wiki/Forward_secrecy)，在 TLS1.3 中已经禁止使用 RSA 作为密钥协商算法。

对于 RSA 的一种攻击方式为选择密文攻击(Chosen Ciphertext Attack)，这种攻击中攻击者可以构造发送密文，并通过服务器的响应来分析密钥和明文信息，这种服务被称为解密提示(Decryption Oracle)。对此的解决方案为使用一种改良的算法:RSA-OAEP(Optimal Asymmetric Encryption Padding, 最优非对称加密填充)。在 OAEP 中会在加密时在明文前填充认证信息，包括明文的散列值以及一些 0,然后再对填充后的明文进行 RSA 加密。在解密过程中，如果没有发现认证信息，则可以确认这是恶意发送的密文，并返回固定的错误消息如“decryption error”。这里的重点是返回固定的错误消息，而不是将具体的错误内容返回，这样攻击者就无法得知任何有效信息。同时，因为 OAEP 通过填充动作把随机性注入明文中，这样在公钥和明文相同的情况下，密文也会不同，进一步提高了安全性。

注意，实际上非对称式加密中，私钥实际上已经包含了公钥的信息，可以通过如 openssl 等一些工具很方便的从私钥中提取公钥。对私钥进行 decode 并进行一些计算后也可得到公钥。在后续的一些使用中，如果看到需要密钥对的情况但是只使用了私钥，其实也是可以达到相同目的的。

公钥密码解决了密钥配送的问题，但是却无法判断接收到的公钥是否合法，常见的攻击即为针对于此的中间人攻击。为了解决这个问题，需要用到后文将描述的数字证书的技术。

下面的代码通过用公钥加密明文字符串，再用私钥解密密文，填充方式为 OAEP。填充过程需要使用到上一节描述过的伪随机数生成器。可以看到，在生成密钥对时，需要指定密钥长度(即模数，位表示)和公开短指数。

在输出密钥对时，有多个参数，下面进行简单的解释。N 代表模数，通常为 1024 或 2048bit。E 为公开短指数。(N,E)的组合构成公钥本身。D 代表私密指数，(N,D)的组合代表私钥本身。P 和 Q 为参与计算的大素数。DP,DQ,QP 用于加速解密过程。

[rsa_encrypt](../src/libmbedtls/toolbox/rsa_encrypt.c ':include')

最后，椭圆曲线密码(Elliptic Curve Cryptography, ECC)是另外一种近些年备受关注的公钥密码算法，特点是所需密钥长度比 RSA 短，但同样可达到较高的安全强度。

对于 RSA 加密，目前来讲如果投入较大计算资源，1024bit 的 RSA 是完全可能被破解的，实际使用中应使用 2048bit 、3072bit 或 4096bit 的 RSA。目前在 GnuPG 中，创建密钥的长度默认就为 3072bit。

## DH 密钥协商算法

在 DH 密钥协商算法中，双方交换一些信息，这些信息即使被窃听者得到也没有关系。根据交换的消息，双方可以各自生成相同的密钥，但是窃听者却无法生成。

DH 密钥协商算法是基于离散对数问题的密钥协商算法的另一种实现,其只能作为密钥协商算法，而不像 RSA 一样可以同时用于数据加解密以及身份认证。DH 无法解决认证问题，需要配合使用 RSA 或 ECDSA 数字签名来解决。

DH 密钥协商的流程如下:

1. 双方先选择相同的大素数 P 与生成元 G 作为共享参数。这两个参数非常重要，可以从标准文件 RFC 7919 中获取标准数据。为了保证安全性，大素数长度应与 RSA 的模数长度相同，实际应用中应不小于 2048bit。
2. 双方均生成一个随机密钥作为私密参数，通过模幂运算计算出要进行交换的公开参数。
3. 接收到对方的公开参数后，通过计算得出共享密钥，随后即可进行通信。

如下代码演示了 DH 密钥协商算法的实现流程。由于是模拟实现，并没有发生网络通信的步骤。可以看到最终生成的公开参数与共享密钥均为 2048bit。可以看到，DH 密钥协商的缺点在于密钥的尺寸太大，这在很多场景下是种限制。

[dh](../src/libmbedtls/dh.c ':include')

## ECDH 密钥协商算法

ECDH 密钥协商基于 ECC 椭圆密码系统，较短的密钥长度即可达到和 RSA 或 DH 算法同等级的强度，ECC 具有密钥尺寸短，安全性高等特点，是近些年密码学应用领域的研究热点。ECDH 也无法解决认证问题，需要配合使用 RSA 或 ECDSA 数字签名来解决。

首先需要初始化椭圆曲线的群结构、以及双方公钥对应的椭圆曲线点结构。接下来可以看到，ECDH 在指定标准椭圆曲线后可通过函数直接生成公钥和私钥，而不是像 DH 一样需要指定生成元和大素数的标准参数，因为实际上标准椭圆曲线已经包含了这些参数，椭圆曲线一般推荐使用标准的 secp256r1 与 secp384r1。客户端和服务端进一步通过对方的公钥直接计算共享密钥。

[ecdh](../src/libmbedtls/ecdh.c ':include')

## 数字签名 RSA/DSA/ECDSA

数字签名，是单向散列函数和公钥密码组合。

数字签名可以识别消息是否被篡改，保障完整性，同时也可以保证消息的真实性。这看起来和前面讲过的消息验证码是一样的作用。实际上，数字签名与消息验证码最大的区别在于，数字签名可以防止否认，因为数字签名的私钥只有签名者持有，而消息验证码的私钥由双方共享。

RSA 数字签名算法基于 RSA 密钥系统实现。RSA 数字签名过程与 RSA 加密解密有类似的地方，但是公钥和私钥的使用方式却有明显的区别。在 RSA 数字签名中，私钥用来加密消息，也称签名密钥。公钥用于解密消息，也称验证密钥。而在 RSA 加密解密中，公钥用于加密消息，私钥用于解密消息，这与 RSA 数字签名恰恰相反。不变的是，公钥总是可以公开的，私钥是不能公开的。

如下代码是 RSA 签名与验证的过程，可以看到一些步骤是和 RSA 加解密一样的。随后进行签名与验证的库函数调用。注意，RSA 数字签名存在潜在伪造的问题，解决方案是使用改进过的 RSA-PSS 签名，其对消息散列值签名，而不是对消息本身签名。除此之外，在计算散列值时还会对消息加盐。

[rsa_sign](../src/libmbedtls/rsa_sign.c ':include')

---

DSA 是另外一种数字签名方式。基于 DSA,如果计算过程在椭圆曲线群上完成，则是另外一种应用广泛的数字签名方式:ECDSA。ECDSA 数字签名和 ECDH 类似，因在椭圆曲线群上进行计算，从而较短的密钥长度即可达到 RSA 较长的密钥长度的安全强度。DSA 和 ECDSA 均只提供数字签名功能，不能用于加解密或密钥交换。

ECDSA 首先要对消息摘要进行结算，随后选择椭圆曲线来生成密钥对。接下来进行签名步骤，签名结果中重要的参数为 r 和 s。最后对使用公钥对签名进行验证，可以看到验证函数需要依次输入椭圆曲线结构体、消息、消息长度、公钥 ctx.Q、以及签名结果 r 和 s。

[ecdsa](../src/libmbedtls/ecdsa.c ':include')

## 数字证书 X.509

数字证书，由公钥和数字签名组合。

数字签名和公钥非对称算法使通信变得越来越安全，但是公钥的分发仍存在安全问题。如果攻击者将公钥替换，则可以很容易的对系统发起攻击,如常见的中间人攻击。数字签名过程中需要进行公钥的交换，安全的公钥交换方式为通过可信机构(CA)颁发证书、或者面对面交换。数字证书解决的就是公钥安全分发的问题，它其是用来证实公钥持有者身份的电子文件。数字证书包含公钥的信息，用户身份信息以及来自发行者的数字签名。

一个证书的颁发与验证流程如下:

1. 服务器端生成密钥对，用公钥生成证书签名请求(CSR)，将 CSR 发送给证书认证机构(CA)
2. CA 收到请求，生成服务器端证书，计算服务器端证书的哈希值，并用 CA 的私钥加密该哈希值，加密后的内容叫做签名(Signature)。注意数字证书包含两部分，服务器端公钥、以及用 CA 的私钥加密过的数字签名。
3. 服务器端收到 CA 下发的证书，并在有客户端请求时将自己的证书发给客户端。
4. 客户端收到服务器端证书，并请求 CA 证书，用 CA 证书中的 CA 公钥解密服务器端证书中的 CA 签名，获得一个哈希值。将这个哈希值与服务器端证书的哈希值进行比较，若一致则证明服务器端的证书是有效的。
5. 此时客户端已经可以使用服务器端公钥进行消息加密，服务器端使用自己的私钥进行解密。

如下代码展示一个验证服务器端证书的过程，mbedtls 的函数接口使用起来非常简单，它屏蔽了很多细节。mbedtls_x509_crt_verify 函数中需要指定一个回调函数，在验证成功或失败时进行调用，这里为 my_verify。

[cert](../src/libmbedtls/cert.c ':include')

---

Ref:

- [How to add entropy sources to the entropy pool](https://tls.mbed.org/kb/how-to/add-entropy-sources-to-entropy-pool)
- [mbedtls entropy_poll.c source code](https://github.com/ARMmbed/mbedtls/blob/55a4d938d055a44cdac6baab1b62d1dcc804da0a/library/entropy_poll.c)
- [Arch wiki: Random number generation](https://wiki.archlinux.org/title/Random_number_generation)
- [Is the CBC mode of operation a stream cipher mode?](https://crypto.stackexchange.com/questions/51251/is-the-cbc-mode-of-operation-a-stream-cipher-mode)
- [ShadowSocks 重定向攻击](http://iv4n.cc/shadowsocks/)
- [Redirect attack - Shadowsocks 流密码的不安全因素](https://blog.rexskz.info/redirect-attack-weakness-of-ss-stream-cipher.html#toc-link-2)
- [Block cipher mode of operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)
- [Authenticated_encryption](https://en.wikipedia.org/wiki/Authenticated_encryption)
- [Stream cipher](https://en.wikipedia.org/wiki/Stream_cipher)
- [Block cipher](https://en.wikipedia.org/wiki/Block_cipher)
- [AES 加密模式 填充方法 选择指南](http://www.cxyzjd.com/article/u012088909/108688456)
- [Galois/Counter Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode)
- [authenticated encryption](https://xianmu.github.io/posts/2017-09-13-authenticated-encryption.html)
