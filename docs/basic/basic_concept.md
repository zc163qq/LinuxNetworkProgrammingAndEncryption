# 基本概念与 tricks

本节描述一些很基础，但是容易被忽略的知识点，以及一些看起来写法很简单，但是另含玄机的代码。

## 获取 glibc

ArchLinux 中只有 glibc 的头文件，源代码需要在[官网](https://www.gnu.org/software/libc/started.html)额外下载。在查看源码时，需要注意比如 system 库函数的实现，其定义在头文件 stdlib.h 中，但其实现不在 stdlib.c,一般在同名 c 文件中，此处是 system.c 文件中的 do_system 函数。
有关时效性，可以注意源码中的 change log,如 system 函数的实现已经从原来的 fork+exec 的方式在 2018 年改为使用 posix_spawn 了。

## 条件判断中的位运算符

条件判断中常使用`||`以及`&&`运算符来判断`或`以及`与`条件。而位运算符`|`以及`&`也可以应在条件判断中，只不过它们不会像`||`以及`&&`一样存在短路现象，它们总是会计算运算符前后两个条件。

## 输入的陷阱

输入常使用 scanf 与 fgets,二者各有优点。虽然很常见而且简单，也有需要注意的问题。考虑如下代码

[input](../src/basic/input.c ':include')

代码尝试输入得到两个字符，并输出。但是实际你并不能得到期望的输出。在输出第一个字符后，第二个字符的内容为空。

```bash
$ ./a.out
a b
output: b
output:
```

这是因为 scanf 在输入完成后会在 stdin 中遗留一个换行符，我们通常进行多次输入时没有问题的原因是除了%c 和%[...] 这种正则输入形式，其余格式 scanf 都会处理掉前置的 whitespace。比如常用的%f 就会处理掉遗留的换行符。如果比如一定要用%c 连续输入，那么需要在后续的%c 前加一个前导空格来匹配格式。

除此之外，如果 scanf 所接受的是带有文本的输入形式，如`scanf("order=&d", order)`，scanf 也是不会处理 stdin 中遗留的换行符的，在连续多次 scanf 输入格式化文本时，也要在格式化文本前加入空格，如`scanf(" order=&d", order)`。

而 fgets 的问题是，首先它仅能用来输入字符串。其次，当所输入的内容，再加上一个`\0`还是不能填满数组时，fgets 会在字符串的最后直接接上一个换行符。这个行为和 scanf 是不同的，scanf 是会在 stdin 中遗留换行符，而 fgets 是会直接加上。

## scanf 的整行输入

scanf 在接收字符串时，遇到空格便会终止，导致随后的字符串无法接收。这时可以用 fgets 来接收整行字符串，也可以使用正则表达式形式的 scanf 来接收包含空格的全部字符串。

[scanf_with_whole_line](../src/basic/scanf_with_whole_line.c ':include')

符号`^`代表取反，整个正则的含义即为取除了`\n`以外的整行全部字符。

## 大类型变量存入小类型变量 为何会出现负数

假设 x 是一个 int 类型的变量，占四字节，其存储 100 000 的值，对应的二进制为`0001 1000 0110 1010 0000`。将其赋给 short 类型的 y,y 只有两字节，所以只能保存二进制数值的靠右部分，即`1000 0110 1010 0000`,最高位的 1 在二进制有符号数会被当最负数处理，即其等价于十进制的`-31072`。
