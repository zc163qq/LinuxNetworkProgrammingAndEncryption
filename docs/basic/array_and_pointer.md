# 指针与数组

本节针对指针与数组描述一些需要注意的知识点。

## 数组下标为何从 0 开始

因为下标实际代表的是一个偏移量，它表示当前要引用的元素到数组中第一个元素之间有多少个元素偏移。

## 指针退化

考虑如下代码

[pointer_degeneration](../src/basic/pointer_degeneration.c ':include')

当把数组赋值给指针变量时，指针变量只会包含数组的地址内容相关信息，而对于数组的长度会丢失,这种情况一般被称为指针退化。一个常见的场景是，在将数组变量传递给函数数组形参时，此种现象发生，因为函参数组实际上被当作指针处理,此时计算长度应用 strlen，而不是 sizeof。

## 数组变量指向不可变

创建指针变量时，会为变量分配存储空间。但是创建数组变量时，不会为数组变量分配空间，仅为数组分配空间。编译器仅在数组变量出现的地方将其替换成数组的起始地址。由于数组变量没有被分配空间，所以其不能像指针变量一样指向其他地方。

## 指针变量为何有类型

因为在进行指针加减运算时，需要根据类型来计算在存储器中的地址偏移。如果对 char 指针加 1，指针会指向存储器中下一个地址，因为 char 就占一个字节。如果是 int 指针加 1,那么会对存储器地址加 4,因为 int 占四个字节。

## 数组变量的交换率

考虑如下代码

[array_exchange_rate](../src/basic/array_exchange_rate.c ':include')

这种操作数组变量的方式不太常见，其实它是一个操作数组变量的交换率。我们操作数组时往往写成 `does[3]`这种形式，其与`*(does+3)`是等价的。而`*(does+3)`与`*(3+does)`等价，最终我们得到`*(3+does)`与`3[does]`等价

## 注意字符串常量的不可变性

考虑如下代码

[constant_string](../src/basic/constant_string.c ':include')

这段代码不能如期运行。因为指针指向了字符串常量，而字符串常量是不可变的，这是新手经常容易犯的错误。想要代码如期运行，可以使用字符数组替代指针变量`char cards[]="JQK"`。原因是字符数组会复制一份字符串常量的值到栈中，因而可以修改，而指针直接指向常量区，所以不可修改。如在代码中一定要使用指针变量指向常量，可以用 const 关键字修饰指针变量，这样在尝试修改时，编译即会报错。
